{
    "module": "core",
    "testDir": "../../config.tests",

    "commandline": {
        "options": {
            "doubleconversion": { "type": "enum", "values": [ "no", "qt", "system" ] },
            "eventfd": "boolean",
            "glib": "boolean",
            "iconv": { "type": "enum", "values": [ "no", "yes", "posix", "sun", "gnu" ] },
            "icu": "boolean",
            "inotify": "boolean",
            "journald": "boolean",
            "mimetype-database": "boolean",
            "pcre": { "type": "enum", "values": [ "no", "qt", "system" ] },
            "posix-ipc": { "type": "boolean", "name": "ipc_posix" },
            "pps": { "type": "boolean", "name": "qqnx_pps" },
            "slog2": "boolean",
            "syslog": "boolean",
            "trace": { "type": "optionalString", "values": [ "etw", "lttng", "no", "yes" ] }
        }
    },

    "libraries": {
        "doubleconversion": {
            "label": "DoubleConversion",
            "test": {
                "main": "(void) double_conversion::StringToDoubleConverter::NO_FLAGS;"
            },
            "headers": "double-conversion/double-conversion.h",
            "sources": [
                "-ldouble-conversion"
            ]
        },
        "glib": {
            "label": "GLib",
            "test": {
                "head": "typedef struct _GMainContext GMainContext;",
                "main": [
                    "g_thread_init(NULL);",
                    "(void) g_main_context_default();",
                    "(void) g_source_new(0, 0);",
                    "g_source_add_poll(NULL, NULL);"
                ]
            },
            "headers": "glib.h",
            "sources": [
                { "type": "pkgConfig", "args": "glib-2.0 gthread-2.0" }
            ]
        },
        "posix_iconv": {
            "label": "POSIX iconv",
            "export": "iconv",
            "test": {
                "main": [
                    "iconv_t x = iconv_open(\"\", \"\");",
                    "char *inp, *outp;",
                    "size_t inbytes, outbytes;",
                    "iconv(x, &inp, &inbytes, &outp, &outbytes);",
                    "iconv_close(x);"
                ]
            },
            "headers": "iconv.h",
            "sources": [
                { "libs": "-liconv", "condition": "config.openbsd || config.haiku" },
                { "libs": "", "condition": "!(config.openbsd || config.haiku)" }
            ]
        },
        "gnu_iconv": {
            "label": "GNU libiconv",
            "export": "iconv",
            "test": {
                "main": [
                    "iconv_t x = iconv_open(\"\", \"\");",
                    "const char *inp;",
                    "char *outp;",
                    "size_t inbytes, outbytes;",
                    "iconv(x, &inp, &inbytes, &outp, &outbytes);",
                    "iconv_close(x);"
                ]
            },
            "headers": "iconv.h",
            "sources": [
                "-liconv"
            ]
        },
        "sun_iconv": {
            "label": "SUN libiconv",
            "export": "iconv",
            "test": {
                "inherit": "gnu_iconv"
            },
            "sources": [
                ""
            ]
        },
        "icu": {
            "label": "ICU",
            "test": {
                "main": [
                    "UErrorCode status = U_ZERO_ERROR;",
                    "UCollator *collator = ucol_open(\"ru_RU\", &status);",
                    "if (!U_FAILURE(status))",
                    "    ucol_close(collator);"
                ]
            },
            "headers": [ "unicode/utypes.h", "unicode/ucol.h", "unicode/ustring.h" ],
            "sources": [
                {
                    "builds": {
                        "debug": "-lsicuind -lsicuucd -lsicudtd",
                        "release": "-lsicuin -lsicuuc -lsicudt"
                    },
                    "condition": "config.win32 && !features.shared"
                },
                { "libs": "-licuin -licuuc -licudt", "condition": "config.win32 && features.shared" },
                { "libs": "-licui18n -licuuc -licudata", "condition": "!config.win32" }
            ],
            "use": [
                { "lib": "libdl", "condition": "features.dlopen" }
            ]
        },
        "journald": {
            "label": "journald",
            "test": {
                "main": "sd_journal_send(\"PRIORITY=%i\", LOG_INFO, NULL);"
            },
            "headers": [ "systemd/sd-journal.h", "syslog.h" ],
            "sources": [
                { "type": "pkgConfig", "args": "libsystemd" },
                { "type": "pkgConfig", "args": "libsystemd-journal" }
            ]
        },
        "libatomic": {
            "label": "64 bit atomics",
            "test": {
                "tail": [
                    "void test(volatile std::atomic<std::int64_t> &a)",
                    "{",
                    "    std::int64_t v = a.load(std::memory_order_acquire);",
                    "    while (!a.compare_exchange_strong(v, v + 1,",
                    "                                      std::memory_order_acq_rel,",
                    "                                      std::memory_order_acquire)) {",
                    "        v = a.exchange(v - 1);",
                    "    }",
                    "    a.store(v + 1, std::memory_order_release);",
                    "}"
                ],
                "main": [
                    "void *ptr = (void*)0xffffffc0; // any random pointer",
                    "test(*reinterpret_cast<std::atomic<std::int64_t> *>(ptr));"
                ],
                "qmake": "CONFIG += c++11"
            },
            "headers": [ "atomic", "cstdint" ],
            "sources": [
                "",
                "-latomic"
            ]
        },
        "librt": {
            "label": "clock_gettime()",
            "test": {
                "main": "timespec ts; clock_gettime(CLOCK_REALTIME, &ts);"
            },
            "headers": [ "unistd.h", "time.h" ],
            "sources": [
                "",
                "-lrt"
            ]
        },
        "lttng-ust": {
            "label": "lttng-ust",
            "test": {
                "main": "lttng_session_destroy(nullptr);"
            },
            "headers": "lttng/ust-events.h",
            "sources": [
                { "type": "pkgConfig", "args": "lttng-ust" },
                "-llttng-ust"
            ],
            "use": "libdl"
        },
        "pcre2": {
            "label": "PCRE2",
            "test": {
                "head": "#define PCRE2_CODE_UNIT_WIDTH 16",
                "tail": [
                    "#if (PCRE2_MAJOR < 10) || ((PCRE2_MAJOR == 10) && (PCRE2_MINOR < 20))",
                    "#  error This PCRE version is not supported",
                    "#endif"
                ]
            },
            "headers": "pcre2.h",
            "sources": [
                { "type": "pkgConfig", "args": "libpcre2-16" },
                "-lpcre2-16"
            ]
        },
        "pps": {
            "label": "PPS",
            "test": {
                "main": [
                    "pps_decoder_t decoder;",
                    "pps_decoder_initialize(&decoder, NULL);"
                ]
            },
            "headers": "sys/pps.h",
            "sources": [
                "-lpps"
            ]
        },
        "slog2": {
            "label": "slog2",
            "test": {
                "main": "slog2_set_default_buffer((slog2_buffer_t)-1);"
            },
            "export": "",
            "headers": "sys/slog2.h",
            "sources": [
                "-lslog2"
            ]
        },
        "advapi32": {
            "label": "advapi32",
            "sources": [
                "-ladvapi32"
            ]
        },
        "gdi32": {
            "label": "gdi32",
            "sources": [
                "-lgdi32"
            ]
        },
        "kernel32": {
            "label": "kernel32",
            "sources": [
                "-lkernel32"
            ]
        },
        "netapi32": {
            "label": "netapi32",
            "sources": [
                "-lnetapi32"
            ]
        },
        "ole32": {
            "label": "ole32",
            "sources": [
                "-lole32"
            ]
        },
        "shell32": {
            "label": "shell32",
            "sources": [
                "-lshell32"
            ]
        },
        "uuid": {
            "label": "uuid",
            "sources": [
                "-luuid"
            ]
        },
        "user32": {
            "label": "user32",
            "sources": [
                "-luser32"
            ]
        },
        "winmm": {
            "label": "winmm",
            "sources": [
                "-lwinmm"
            ]
        },
        "ws2_32": {
            "label": "ws2_32",
            "sources": [
                "-lws2_32"
            ]
        }
    },

    "tests": {
        "atomicfptr": {
            "label": "working std::atomic for function pointers",
            "type": "compile",
            "test": {
                "include": "atomic",
                "tail": [
                    "typedef void (*fptr)(int);",
                    "typedef std::atomic<fptr> atomicfptr;",
                    "void testfunction(int) { }",
                    "void test(volatile atomicfptr &a)",
                    "{",
                    "    fptr v = a.load(std::memory_order_acquire);",
                    "    while (!a.compare_exchange_strong(v, &testfunction,",
                    "                                      std::memory_order_acq_rel,",
                    "                                      std::memory_order_acquire)) {",
                    "        v = a.exchange(&testfunction);",
                    "    }",
                    "    a.store(&testfunction, std::memory_order_release);",
                    "}"
                ],
                "main": [
                    "atomicfptr fptr(testfunction);",
                    "test(fptr);"
                ],
                "qmake": "CONFIG += c++11"
            }
        },
        "clock-monotonic": {
            "label": "POSIX monotonic clock",
            "type": "compile",
            "test": {
                "include": [ "unistd.h", "time.h" ],
                "main": [
                    "#if defined(_POSIX_MONOTONIC_CLOCK) && (_POSIX_MONOTONIC_CLOCK-0 >= 0)",
                    "timespec ts;",
                    "clock_gettime(CLOCK_MONOTONIC, &ts);",
                    "#else",
                    "#  error Feature _POSIX_MONOTONIC_CLOCK not available",
                    "#endif"
                ]
            },
            "use": "librt"
        },
        "cloexec": {
            "label": "O_CLOEXEC",
            "type": "compile",
            "test": {
                "head": "#define _GNU_SOURCE 1",
                "include": [ "sys/types.h", "sys/socket.h", "fcntl.h", "unistd.h" ],
                "main": [
                    "int pipes[2];",
                    "(void) pipe2(pipes, O_CLOEXEC | O_NONBLOCK);",
                    "(void) fcntl(0, F_DUPFD_CLOEXEC, 0);",
                    "(void) dup3(0, 3, O_CLOEXEC);",
                    "#if defined(__NetBSD__)",
                    "(void) paccept(0, 0, 0, NULL, SOCK_CLOEXEC | SOCK_NONBLOCK);",
                    "#else",
                    "(void) accept4(0, 0, 0, SOCK_CLOEXEC | SOCK_NONBLOCK);",
                    "#endif"
                ]
            }
        },
        "cxx11_future": {
            "label": "C++11 <future>",
            "type": "compile",
            "test": {
                "include": "future",
                "main": [
                    "std::future<int> f = std::async([]() { return 42; });",
                    "(void)f.get();"
                ],
                "qmake": "unix:LIBS += -lpthread"
            }
        },
        "cxx11_random": {
            "label": "C++11 <random>",
            "type": "compile",
            "test": {
                "include": "random",
                "main": "std::mt19937 mt(0);"
            }
        },
        "eventfd": {
            "label": "eventfd",
            "type": "compile",
            "test": {
                "include": "sys/eventfd.h",
                "main": [
                    "eventfd_t value;",
                    "int fd = eventfd(0, EFD_CLOEXEC);",
                    "eventfd_read(fd, &value);",
                    "eventfd_write(fd, value);"
                ]
            }
        },
        "futimens": {
            "label": "futimens()",
            "type": "compile",
            "test": {
                "include": "sys/stat.h",
                "main": "futimens(-1, 0);",
                "qmake": [
                    "# Block futimens() on Apple platforms unless it's available on ALL",
                    "# deployment targets. This simplifies the logic at the call site",
                    "# dramatically, as it isn't strictly needed compared to futimes().",
                    "darwin: QMAKE_CXXFLAGS += -Werror=unguarded-availability -Werror=unguarded-availability-new",
                    "CONFIG += warn_on"
                ]
            }
        },
        "futimes": {
            "label": "futimes()",
            "type": "compile",
            "test": {
                "include": "sys/time.h",
                "main": "futimes(-1, 0);"
            }
        },
        "getauxval": {
            "label": "getauxval()",
            "type": "compile",
            "test": {
                "include": "sys/auxv.h",
                "main": "(void) getauxval(AT_NULL);"
            }
        },
        "getentropy": {
            "label": "getentropy()",
            "type": "compile",
            "test": {
                "include": "unistd.h",
                "main": [
                    "char buf[32];",
                    "(void) getentropy(buf, sizeof(buf));"
                ]
            }
        },
        "glibc": {
            "label": "GNU libc",
            "type": "compile",
            "test": {
                "include": "stdlib.h",
                "main": [
                    "return __GLIBC__;"
                ]
            }
        },
        "inotify": {
            "label": "inotify",
            "type": "compile",
            "test": {
                "include": "sys/inotify.h",
                "main": [
                    "inotify_init();",
                    "inotify_add_watch(0, \"foobar\", IN_ACCESS);",
                    "inotify_rm_watch(0, 1);"
                ]
            }
        },
        "ipc_sysv": {
            "label": "SysV IPC",
            "type": "compile",
            "test": {
                "include": [ "sys/types.h", "sys/ipc.h", "sys/sem.h", "sys/shm.h", "fcntl.h" ],
                "main": [
                    "key_t unix_key = ftok(\"test\", 'Q');",
                    "semctl(semget(unix_key, 1, 0666 | IPC_CREAT | IPC_EXCL), 0, IPC_RMID, 0);",
                    "shmget(unix_key, 0, 0666 | IPC_CREAT | IPC_EXCL);",
                    "shmctl(0, 0, (struct shmid_ds *)(0));"
                ]
            }
        },
        "ipc_posix": {
            "label": "POSIX IPC",
            "type": "compile",
            "test": {
                "include": [ "sys/types.h", "sys/mman.h", "semaphore.h", "fcntl.h" ],
                "main": [
                    "sem_close(sem_open(\"test\", O_CREAT | O_EXCL, 0666, 0));",
                    "shm_open(\"test\", O_RDWR | O_CREAT | O_EXCL, 0666);",
                    "shm_unlink(\"test\");"
                ],
                "qmake": "linux: LIBS += -lpthread -lrt"
            }
        },
        "linkat": {
            "label": "linkat()",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "fcntl.h", "unistd.h" ],
                "main": "linkat(AT_FDCWD, \"foo\", AT_FDCWD, \"bar\", AT_SYMLINK_FOLLOW);"
            }
        },
        "ppoll": {
            "label": "ppoll()",
            "type": "compile",
            "test": {
                "include": [ "signal.h", "poll.h" ],
                "main": [
                    "struct pollfd pfd;",
                    "struct timespec ts;",
                    "sigset_t sig;",
                    "ppoll(&pfd, 1, &ts, &sig);"
                ]
            }
        },
        "pollts": {
            "label": "pollts()",
            "type": "compile",
            "test": {
                "include": [ "poll.h", "signal.h", "time.h" ],
                "main": [
                    "struct pollfd pfd;",
                    "struct timespec ts;",
                    "sigset_t sig;",
                    "pollts(&pfd, 1, &ts, &sig);"
                ]
            }
        },
        "poll": {
            "label": "poll()",
            "type": "compile",
            "test": {
                "include": "poll.h",
                "main": [
                    "struct pollfd pfd;",
                    "poll(&pfd, 1, 0);"
                ]
            }
        },
        "renameat2": {
            "label": "renameat2()",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "fcntl.h", "stdio.h" ],
                "main": "renameat2(AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_NOREPLACE | RENAME_WHITEOUT);"
            }
        },
        "statx": {
            "label": "statx() in libc",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "sys/types.h", "sys/stat.h", "unistd.h", "fcntl.h" ],
                "main": [
                    "struct statx statxbuf;",
                    "unsigned int mask = STATX_BASIC_STATS;",
                    "return statx(AT_FDCWD, \"\", AT_STATX_SYNC_AS_STAT, mask, &statxbuf);"
                ]
            }
        },
        "syslog": {
            "label": "syslog",
            "type": "compile",
            "test": {
                "include": "syslog.h",
                "main": [
                    "openlog(\"qt\", 0, LOG_USER);",
                    "syslog(LOG_INFO, \"configure\");",
                    "closelog();"
                ]
            }
        },
        "xlocalescanprint": {
            "label": "xlocale.h (or equivalents)",
            "type": "compile",
            "test": {
                "files": {
                    "qglobal.h": [
                        "#ifndef QGLOBAL_H",
                        "#define QGLOBAL_H",
                        "#endif"
                    ]
                },
                "tail": [
                    "#define QT_BEGIN_NAMESPACE",
                    "#define QT_END_NAMESPACE",
                    "",
                    "#ifdef _MSVC_VER",
                    "#define Q_CC_MSVC _MSVC_VER",
                    "#endif",
                    "",
                    "#define QT_NO_DOUBLECONVERSION",
                    "",
                    "#include QDSP_P_H"
                ],
                "main": [
                    "#ifdef _MSVC_VER",
                    "_locale_t invalidLocale = NULL;",
                    "#else",
                    "locale_t invalidLocale = NULL;",
                    "#endif",
                    "double a = 3.4;",
                    "qDoubleSnprintf(argv[0], 1, invalidLocale, \"invalid format\", a);",
                    "qDoubleSscanf(argv[0], invalidLocale, \"invalid format\", &a, &argc);"
                ],
                "qmake": "DEFINES += QDSP_P_H=$$shell_quote(\\\"@PWD@/text/qdoublescanprint_p.h\\\")"
            }
        }
    },

    "features": {
        "clock-gettime": {
            "label": "clock_gettime()",
            "condition": "config.unix && libs.librt",
            "output": [ "privateFeature" ]
        },
        "clock-monotonic": {
            "label": "POSIX monotonic clock",
            "condition": "features.clock-gettime && tests.clock-monotonic",
            "output": [ "feature" ]
        },
        "doubleconversion": {
            "label": "DoubleConversion",
            "output": [ "privateFeature", "feature" ]
        },
        "system-doubleconversion": {
            "label": "  Using system DoubleConversion",
            "enable": "input.doubleconversion == 'system'",
            "disable": "input.doubleconversion == 'qt'",
            "condition": "features.doubleconversion && libs.doubleconversion",
            "output": [ "privateFeature" ]
        },
        "cxx11_future": {
            "label": "C++11 <future>",
            "condition": "tests.cxx11_future",
            "output": [ "publicFeature" ]
        },
        "eventfd": {
            "label": "eventfd",
            "condition": "!config.wasm && tests.eventfd",
            "output": [ "feature" ]
        },
        "futimens": {
            "label": "futimens()",
            "condition": "!config.win32 && tests.futimens",
            "output": [ "privateFeature" ]
        },
        "futimes": {
            "label": "futimes()",
            "condition": "!config.win32 && !features.futimens && tests.futimes",
            "output": [ "privateFeature" ]
        },
        "getauxval": {
            "label": "getauxval()",
            "condition": "config.linux && tests.getauxval",
            "output": [ "privateFeature" ]
        },
        "getentropy": {
            "label": "getentropy()",
            "condition": "config.unix && tests.getentropy",
            "output": [ "privateFeature" ]
        },
        "glib": {
            "label": "GLib",
            "autoDetect": "!config.win32",
            "condition": "libs.glib",
            "output": [ "privateFeature", "feature" ]
        },
        "glibc": {
            "label": "GNU libc",
            "autoDetect": "config.linux",
            "condition": "tests.glibc",
            "output": [ "privateFeature" ]
        },
        "iconv": {
            "label": "iconv",
            "purpose": "Provides internationalization on Unix.",
            "section": "Internationalization",
            "condition": "!features.icu && features.textcodec && (features.posix-libiconv || features.sun-libiconv || features.gnu-libiconv)",
            "output": [ "privateFeature", "feature" ]
        },
        "posix-libiconv": {
            "label": "POSIX iconv",
            "enable": "input.iconv == 'posix'",
            "disable": "input.iconv == 'sun' || input.iconv == 'gnu' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && libs.posix_iconv",
            "output": [ "privateFeature" ]
        },
        "sun-libiconv": {
            "label": "SUN iconv",
            "enable": "input.iconv == 'sun'",
            "disable": "input.iconv == 'posix' || input.iconv == 'gnu' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && !features.posix-libiconv && libs.sun_iconv"
        },
        "gnu-libiconv": {
            "label": "GNU iconv",
            "enable": "input.iconv == 'gnu'",
            "disable": "input.iconv == 'posix' || input.iconv == 'sun' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && !features.posix-libiconv && !features.sun-libiconv && libs.gnu_iconv",
            "output": [ "privateFeature" ]
        },
        "icu": {
            "label": "ICU",
            "autoDetect": "!config.win32",
            "condition": "libs.icu",
            "output": [ "privateFeature" ]
        },
        "inotify": {
            "label": "inotify",
            "condition": "tests.inotify",
            "output": [ "privateFeature", "feature" ]
        },
        "ipc_posix": {
            "label": "Using POSIX IPC",
            "autoDetect": "!config.win32",
            "condition": "!tests.ipc_sysv && tests.ipc_posix",
            "output": [ { "type": "define", "name": "QT_POSIX_IPC" } ]
        },
        "journald": {
            "label": "journald",
            "autoDetect": false,
            "condition": "libs.journald",
            "output": [ "privateFeature" ]
        },
        "linkat": {
            "label": "linkat()",
            "comment": "Currently only used by QTemporaryFile; linkat() exists on Android, but hardlink creation fails due to security rules",
            "autoDetect": "config.linux && !config.android",
            "condition": "tests.linkat",
            "output": [ "privateFeature" ]
        },
        "std-atomic64": {
            "label": "64 bit atomic operations",
            "condition": "libs.libatomic",
            "output": [ "publicFeature" ]
        },
        "mimetype": {
            "label": "Mimetype handling",
            "purpose": "Provides MIME type handling.",
            "section": "Utilities",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "mimetype-database": {
            "label": "Built-in copy of the MIME database",
            "condition": "features.mimetype",
            "output": [ "privateFeature" ]
        },
        "pcre2": {
            "label": "PCRE2",
            "disable": "input.pcre == 'no' || input.pcre == 'system'",
            "enable": "input.pcre == 'qt'",
            "output": [ "privateConfig" ]
        },
        "system-pcre2": {
            "label": "  Using system PCRE2",
            "disable": "input.pcre == 'no' || input.pcre == 'qt'",
            "enable": "input.pcre == 'system'",
            "condition": "libs.pcre2",
            "output": [ "privateFeature" ]
        },
        "poll_ppoll": {
            "label": "Native ppoll()",
            "emitIf": "!config.win32",
            "condition": "!config.wasm && tests.ppoll",
            "output": [ "privateFeature" ]
        },
        "poll_pollts": {
            "label": "Native pollts()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && tests.pollts",
            "output": [ "privateFeature" ]
        },
        "poll_poll": {
            "label": "Native poll()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && !features.poll_pollts && tests.poll",
            "output": [ "privateFeature" ]
        },
        "poll_select": {
            "label": "Emulated poll()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && !features.poll_pollts && !features.poll_poll",
            "output": [
                "privateFeature",
                { "type": "define", "name": "QT_NO_NATIVE_POLL" }
            ]
        },
        "qqnx_pps": {
            "label": "PPS",
            "emitIf": "config.qnx",
            "condition": "libs.pps",
            "output": [ "privateFeature" ]
        },
        "qeventtransition": {
            "label": "QEventTransition class",
            "condition": "features.statemachine",
            "output": [ "publicFeature" ]
        },
        "renameat2": {
            "label": "renameat2()",
            "condition": "config.linux && tests.renameat2",
            "output": [ "privateFeature" ]
        },
        "slog2": {
            "label": "slog2",
            "condition": "libs.slog2",
            "output": [ "privateFeature" ]
        },
        "statx": {
            "label": "statx() in libc",
            "condition": "config.linux && tests.statx",
            "output": [ "privateFeature" ]
        },
        "syslog": {
            "label": "syslog",
            "autoDetect": false,
            "condition": "tests.syslog",
            "output": [ "privateFeature" ]
        },
        "threadsafe-cloexec": {
            "label": "Threadsafe pipe creation",
            "condition": "tests.cloexec",
            "output": [
                "publicQtConfig",
                { "type": "define", "name": "QT_THREADSAFE_CLOEXEC", "value": 1 }
            ]
        },
        "properties": {
            "label": "Properties",
            "purpose": "Supports scripting Qt-based applications.",
            "section": "Kernel",
            "output": [ "publicFeature", "feature" ]
        },
        "regularexpression": {
            "label": "QRegularExpression",
            "purpose": "Provides an API to Perl-compatible regular expressions.",
            "section": "Kernel",
            "condition": "features.system-pcre2 || features.pcre2",
            "output": [ "publicFeature", "feature" ]
        },
        "sharedmemory": {
            "label": "QSharedMemory",
            "purpose": "Provides access to a shared memory segment.",
            "section": "Kernel",
            "condition": [
                "config.android || config.win32 || (!config.vxworks && (tests.ipc_sysv || tests.ipc_posix))"
            ],
            "output": [ "publicFeature", "feature" ]
        },
        "systemsemaphore": {
            "label": "QSystemSemaphore",
            "purpose": "Provides a general counting system semaphore.",
            "section": "Kernel",
            "condition": [
                "!config.integrity && !config.vxworks && !config.rtems",
                "config.android || config.win32 || tests.ipc_sysv || tests.ipc_posix"
            ],
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstream": {
            "label": "XML Streaming APIs",
            "purpose": "Provides a simple streaming API for XML.",
            "section": "Kernel",
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstreamreader": {
            "label": "QXmlStreamReader",
            "purpose": "Provides a well-formed XML parser with a simple streaming API.",
            "section": "Kernel",
            "condition": "features.xmlstream",
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstreamwriter": {
            "label": "QXmlStreamWriter",
            "purpose": "Provides a XML writer with a simple streaming API.",
            "section": "Kernel",
            "condition": "features.xmlstream",
            "output": [ "publicFeature", "feature" ]
        },
        "textdate": {
            "label": "Text Date",
            "purpose": "Supports month and day names in dates.",
            "section": "Data structures",
            "output": [ "publicFeature", "feature" ]
        },
        "datestring": {
            "label": "QDate/QTime/QDateTime",
            "purpose": "Provides conversion between dates and strings.",
            "section": "Data structures",
            "condition": "features.textdate",
            "output": [ "publicFeature", "feature" ]
        },
        "process": {
            "label": "QProcess",
            "purpose": "Supports external process invocation.",
            "section": "File I/O",
            "condition": "features.processenvironment && !config.winrt && !config.uikit && !config.integrity && !config.vxworks && !config.rtems",
            "output": [ "publicFeature", "feature" ]
        },
        "processenvironment": {
            "label": "QProcessEnvironment",
            "purpose": "Provides a higher-level abstraction of environment variables.",
            "section": "File I/O",
            "condition": "!config.winrt && !config.integrity && !config.rtems",
            "output": [ "publicFeature" ]
        },
        "temporaryfile": {
            "label": "QTemporaryFile",
            "purpose": "Provides an I/O device that operates on temporary files.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "library": {
            "label": "QLibrary",
            "purpose": "Provides a wrapper for dynamically loaded libraries.",
            "section": "File I/O",
            "condition": "config.win32 || config.hpux || (!config.nacl && features.dlopen)",
            "output": [ "publicFeature", "feature" ]
        },
        "settings": {
            "label": "QSettings",
            "purpose": "Provides persistent application settings.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "filesystemwatcher": {
            "label": "QFileSystemWatcher",
            "purpose": "Provides an interface for monitoring files and directories for modifications.",
            "section": "File I/O",
            "condition": "!config.winrt",
            "output": [ "publicFeature", "feature" ]
        },
        "filesystemiterator": {
            "label": "QFileSystemIterator",
            "purpose": "Provides fast file system iteration.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "itemmodel": {
            "label": "Qt Item Model",
            "purpose": "Provides the item model for item views",
            "section": "ItemViews",
            "output": [ "publicFeature", "feature" ]
        },
        "proxymodel": {
            "label": "QAbstractProxyModel",
            "purpose": "Supports processing of data passed between another model and a view.",
            "section": "ItemViews",
            "condition": "features.itemmodel",
            "output": [ "publicFeature", "feature" ]
        },
        "sortfilterproxymodel": {
            "label": "QSortFilterProxyModel",
            "purpose": "Supports sorting and filtering of data passed between another model and a view.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "identityproxymodel": {
            "label": "QIdentityProxyModel",
            "purpose": "Supports proxying a source model unmodified.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "transposeproxymodel": {
            "label": "QTransposeProxyModel",
            "purpose": "Provides a proxy to swap rows and columns of a model.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "concatenatetablesproxymodel": {
            "label": "QConcatenateTablesProxyModel",
            "purpose": "Supports concatenating source models.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "stringlistmodel": {
            "label": "QStringListModel",
            "purpose": "Provides a model that supplies strings to views.",
            "section": "ItemViews",
            "condition": "features.itemmodel",
            "output": [ "publicFeature", "feature" ]
        },
        "translation": {
            "label": "Translation",
            "purpose": "Supports translations using QObject::tr().",
            "section": "Internationalization",
            "output": [ "publicFeature", "feature" ]
        },
        "textcodec": {
            "label": "QTextCodec",
            "purpose": "Supports conversions between text encodings.",
            "section": "Internationalization",
            "output": [ "publicFeature", "feature" ]
        },
        "codecs": {
            "label": "Codecs",
            "purpose": "Supports non-unicode text conversions.",
            "section": "Internationalization",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "big_codecs": {
            "label": "Big Codecs",
            "purpose": "Supports big codecs, e.g. CJK.",
            "section": "Internationalization",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "easingcurve": {
            "label": "Easing curve",
            "purpose": "Provides easing curve.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "animation": {
            "label": "Animation",
            "purpose": "Provides a framework for animations.",
            "section": "Utilities",
            "condition": "features.properties && features.easingcurve",
            "output": [ "publicFeature", "feature" ]
        },
        "statemachine": {
            "label": "State machine",
            "purpose": "Provides hierarchical finite state machines.",
            "section": "Utilities",
            "condition": "features.properties",
            "output": [ "publicFeature", "feature" ]
        },
        "gestures": {
            "label": "Gesture",
            "purpose": "Provides a framework for gestures.",
            "section": "Utilities",
            "output": [ "publicFeature", "feature" ]
        },
        "sha3-fast": {
            "label": "Speed optimized SHA3",
            "purpose": "Optimizes SHA3 for speed instead of size.",
            "section": "Utilities",
            "output": [ "privateFeature" ]
        },
        "jalalicalendar": {
            "label": "QJalaliCalendar",
            "purpose": "Support the Jalali (Persian) calendar",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "hijricalendar": {
            "label": "QHijriCalendar",
            "purpose": "Generic basis for Islamic calendars, providing shared locale data",
            "section": "Utilities",
            "output": [ "privateFeature" ]
        },
        "islamiccivilcalendar": {
            "label": "QIslamicCivilCalendar",
            "purpose": "Support the Islamic Civil calendar",
            "section": "Utilities",
            "condition": "features.hijricalendar",
            "output": [ "publicFeature" ]
        },
        "timezone": {
            "label": "QTimeZone",
            "purpose": "Provides support for time-zone handling.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "datetimeparser": {
            "label": "QDateTimeParser",
            "purpose": "Provides support for parsing date-time texts.",
            "section": "Utilities",
            "output": [ "privateFeature" ]
        },
        "commandlineparser": {
            "label": "QCommandlineParser",
            "purpose": "Provides support for command line parsing.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "lttng": {
            "label": "LTTNG",
            "autoDetect": false,
            "enable": "input.trace == 'lttng' || (input.trace =='yes' && config.linux)",
            "disable": "input.trace == 'etw' || input.trace =='no'",
            "condition": "config.linux && libs.lttng-ust",
            "output": [ "privateFeature" ]
        },
        "etw": {
            "label": "ETW",
            "autoDetect": false,
            "enable": "input.trace == 'etw' || (input.trace == 'yes' && config.win32)",
            "disable": "input.trace == 'lttng' || input.trace == 'no'",
            "condition": "config.win32",
            "output": [ "privateFeature" ]
        },
        "topleveldomain": {
            "label": "QUrl::topLevelDomain()",
            "purpose": "Provides support for extracting the top level domain from URLs.

If enabled, a binary dump of the Public Suffix List (http://www.publicsuffix.org,
Mozilla License) is included. The data is then also used in QNetworkCookieJar::validateCookie.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "win32_system_libs": {
            "label": "Windows System Libraries",
            "condition": "config.win32 && libs.advapi32 && libs.gdi32 && libs.kernel32 && libs.netapi32 && libs.ole32 && libs.shell32 && libs.uuid && libs.user32 && libs.winmm && libs.ws2_32"
        },
        "cborstreamreader": {
            "label": "CBOR stream reading",
            "purpose": "Provides support for reading the CBOR binary format.

Note that this is required for plugin loading. Qt GUI needs QPA plugins for basic operation.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "cborstreamwriter": {
            "label": "CBOR stream writing",
            "purpose": "Provides support for writing the CBOR binary format.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "binaryjson": {
            "label": "Binary JSON (deprecated)",
            "purpose": "Provides support for the deprecated binary JSON format.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        }
    },

    "report": [
        {
            "type": "note",
            "condition": "features.journald || features.syslog || (config.qnx && features.slog2)",
            "message": "journald, syslog or slog2 integration is enabled.
If your users intend to develop applications against this build,
ensure that the IDEs they use either set QT_FORCE_STDERR_LOGGING to 1
or are able to read the logged output from journald, syslog or slog2."
        },
        {
            "type": "error",
            "condition": "!tests.cxx11_random",
            "message": "C++11 <random> is required and is missing or failed to compile."
        },
        {
            "type": "error",
            "condition": "input.doubleconversion == 'no' && !tests.xlocalescanprint",
            "message": "Your C library does not provide sscanf_l or snprintf_l.
You need to use libdouble-conversion for double/string conversion."
        },
        {
            "type": "error",
            "condition": "!tests.atomicfptr",
            "message": "detected a std::atomic implementation that fails for function pointers.
Please apply the patch corresponding to your Standard Library vendor, found in
  qtbase/config.tests/atomicfptr"
        },
        {
            "type": "error",
            "condition": [
                "config.unix || config.integrity",
                "!features.poll_ppoll",
                "!features.poll_pollts",
                "!features.poll_poll",
                "!features.poll_select"
            ],
            "message": "Qt requires poll(), ppoll(), poll_ts() or select() on this platform"
        }
    ],

    "summary": [
        {
            "section": "Qt Core",
            "entries": [
                "doubleconversion",
                "system-doubleconversion",
                "glib",
                "iconv",
                "icu",
                "mimetype-database",
                {
                    "message": "Tracing backend",
                    "type": "firstAvailableFeature",
                    "args": "etw lttng"
                },
                {
                    "section": "Logging backends",
                    "entries": [
                        "journald", "syslog", "slog2"
                    ]
                },
                {
                    "type": "feature",
                    "args": "qqnx_pps",
                    "condition": "config.qnx"
                },
                "pcre2",
                "system-pcre2"
            ]
        }
    ]
}
